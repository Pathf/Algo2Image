\documentclass{article}
\usepackage[utf8]{inputenc} %cp1252 pour Windows, utf8 pour Linux
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage[frenchb]{babel}
\usepackage{hyperref}
\usepackage[table,xcdraw]{xcolor}
\usepackage{float}

\newcommand{\info}{\texttt}
\newcommand{\qt}{\info{QuadTree}}

\title{Algorithmique et Structure de Données 2\\
Rapport Projet 2}
\author{Valentin \bsc{Hénique} \and Corentin \bsc{Chédotal}}
\date{02 Mai 2016}

\begin{document}

\maketitle

\section{Introduction}

Dans le cadre de l'Unité d'Enseignement X4I0030 intitulée "Algorithmique et Structure de Données 2" nous avons été amené à produire un second et dernier projet. Celui-ci consiste en la réalisation d'un algorithme de compression d'images bitmap. Pour ce faire nous avions à notre disposition un arbre de recherche d'arité 4 : le \qt. Il était donc demandé de représenter les images à travers ces arbres particuliers en suivant une méthode spécifique expliquée dans le sujet. Ceci fait il nous fallait appliquer nos algorithmes de compressions et comparer divers réglages de ceux-ci.
Le langage de programmation demandé étant le C++.\\
Ce rapport expliquera donc comment ces algorithmes ont été mis en place ainsi que les contraintes mémorielles et temporaires de ceux-ci. Nous comparerons d'ailleurs différents fonctionnements de ceux-ci dans des environnements de test spécifiques qui eux aussi seront expliqués.

\section{Implémentation}

Afin de répondre aux exigences du sujet plusieurs décisions concernant l'implémentation ont été prises. Tout d'abord comme demandé l'encodage des images se fait initialement par l'intermédiaire de la structure ImagePNG puis le stockage se fait dans la structure arbre d'arité 4 \qt telle que présentée dans le sujet et donnée dans la bibliothèque fournie. C'est dans cette structure que les éventuelles opérations de compression (sans-perte, delta ou phi) sont effectuées. Il a aussi été décidé que pour les méthodes nécessitant de travailler sur l'arbre une approche récursive serait la plus appropriée et donc les méthodes publiques font souvent appel à des méthodes privées dont le fonctionnement est récursif. Le but de cette pseudo-duplication des méthodes était de ne pas changer les méthodes publiques par rapport à celles données de base à l'exercice tout en ayant la possibilité de faire ce fonctionnement récursif qui nécessitait des paramètres supplémentaires.\\
Enfin la liste de toutes les méthodes employées est explicitée ci-après.

    \subsection{Méthodes employées}

		\subsubsection{Méthodes publiques}
		
		\begin{itemize}
	    	\item \info{QuadTree()} : Constructeur initialisant un arbre d'arité 4 vide.
	    	\item \info{~QuadTree()} : Destructeur faisant appel à la méthode \info{destructeur()} sur la racine du \qt.
	    	\item \info{afficher()} : Méthode d'affichage textuel du contenu d'un \qt, appelle la méthode \info{afficher_rec()} sur la racine dans le cas d'un arbre non vide. Présente à des fins de debugging.
	    	\item \info{importer(const ImagePNG \& img)} : Encode l'image Bitmap img (au format ImagePNG) dans le \qt. Emploie la méthode \info{importer_rec()}. L'image doit être de dimension $2\up{n}\times2\up{n}$ avec $n>0$.
	    	\item \info{exporter()} : Méthode exportant le contenu du \qt dans une image sous le format ImagePNG. Fait appel au constructeur d'ImagePNG et à \info{exporter_rec()}.
	    	\item \info{compressionDelta(unsigned delta)} : Méthode de compression d'un \qt et donc de son image associée basée sur un seuil maximal de différence en luminance entre les pixels. Ici delta est le seuil choisi pour la compression. Etant donné les limites des couleurs des pixels on a $delta<255$. Emploie ou \info{compressionSansPerte_rec()} ou \info{compressionDelta_rec} suivant la valeur de delta.
	    	\item \info{compressionPhi(unsigned phi)} : Autre méthode de compression d'un \qt et de l'image encodée dans celui-ci. Celle-ci est basée sur un nombre maximal de feuilles restant après la compression. Ce nombre est le paramètre phi, or la compression ne pouvant aps supprimer le \qt dans son intégralité on a $phi>0$. Fais appel à la méthode privée \info{compressionPhi_rec()}.
	    \end{itemize}
	    
	    \subsubsection{Méthodes facilitatrices (privées)}
	    
	    \begin{itemize}
	    	\item \info{kiemeBit(unsigned n, unsigned k)} : Méthode statique simple retournant la valeur du k-ième bit d'un entier n positif. Présente afin de simplifier les calculs.
	    	\item \info{afficher_rec(const Noeud * n, std::string tabs="")} : Méthode d'affichage textuel du \qt de façon récursive. Le paramètre n est le noeud duquel l'affichage se fait en "descendant".
	    	\item \info{destructeur(Noeud * ptr)} : Méthode détruisant les nœuds et feuilles "plus bas" que ptr de façon récursive. Permet donc des destructions "sélectives" ou un emploi général depuis la racine comme destructeur du \qt entier.
	    	\item \info{importer_rec(Noeud * ptr, unsigned taille, const ImagePNG \& img, unsigned x, unsigned y)} : Méthode créant le \qt à partir d'une image de façon récursive en "descendant" et construisant l'arbre petit à petit, le remplissant des valeurs des pixels au fur et à mesure. Ici ptr est le noeud à partir duquel on descend pour contruire les feuilles suivantes, taille est la largeur de l'image, image est l'image au format ImagePNG à encoder dans le \qt et x et y sont les positions en cours afin de placer correctement les pixels aux bons endroits de l'arbre. L'image doit par contre être au format $2\up{n}\times2\up{n}$ avec $n>0$.
	    	\item \info{exporter_rec(const Noeud* ptr, unsigned taille, ImagePNG \& img, unsigned x, unsigned y)} : Méthode créant une image au format ImagePNG depuis les valeurs des pixels encodés dans le \qt de façon récursive. Fonctionne de la même façon que plus haut mais ici on va extraire les valeurs des feuilles de l'arbre afin de les mettre dans les pixels correspondant de image. A nouveau l'image doit être au format $2\up{n}\times2\up{n}$ avec $n>0$.
	    	\item \info{compressionSansPerte_rec(Noeud* ptr, unsigned taille)} : Algorithme de compression récursif d'une image sans perte (dans le cas d'une compression Delta avec delta=0). Le paramètre ptr est le pointeur vers le Noeud duquel on effectue les éventuelles opérations de compression sur ses feuilles, taille est simplement la largeur de l'image.
	    	\item \info{compressionDelta_rec(Noeud* ptr, unsigned taille, unsigned delta)} : Algorithme de compression récursif d'une image avec perte basée sur la différence de luminance des pixels voisins. Le paramètre ptr est le pointeur vers le Noeud duquel on effectue les éventuelles opérations de compression sur ses feuilles, taille est simplement la largeur de l'image et delta est la différence de luminance requise.
	    	\item \info{compressionPhi_rec(Noeud* ptr, unsigned phi)} : Algorithme de compression récursif d'une image avec perte, la compression se faisant afin d'atteindre un certain nombre maximum de feuilles dans le \qt. Le paramètre ptr est le pointeur vers le Noeud duquel on effectue les éventuelles opérations de compression sur ses feuilles, phi est le nombre maximum de feuilles autorisées dans l'arbre.
	    \end{itemize}
    
    \subsection{Encombrement mémoire}
    
    PLACEHOLDER
    
    \subsection{Complexités temporelles}

    Travaillant avec des images pouvant atteindre des tailles particulièrement grandes l'étude de la complexité temporelle des différents algorithmes employés est particulièrement importantes. Il faut pouvoir optimiser au maximum ceux-ci puisque dans le cas des images de plus de huit mille pixels de largeur certaines opérations seront donc effectuées sur plus de soixante-quatre millions de pixels. Nous allons donc fournir ici les complexités théoriques ainsi que divers exemples d'utilisation des \qt et les valeurs expérimentales de temps d'exécution.
    
        \subsubsection{Complexités temporelles théoriques}
        
        Ci-dessous se trouve un tableau des complexités temporelles théoriques des diverses méthodes du \qt :
        \begin{table}[H]
        	\centering
        	\label{ComplexiteTheo}
        	\begin{tabular}{|l|l|}
        		\hline
        		\rowcolor[HTML]{C0C0C0} 
        		{\color[HTML]{333333} \textbf{Méthodes}} & \textbf{Complexité} \\ \hline
        		\info{QuadTree()}                                 &  $\Theta(1)$                   \\ \hline
        		\info{\char`\~QuadTree()}                                &  A DETERMINER (n ?)                   \\ \hline
        		\info{afficher()}                                &  A DETERMINER (n ?)                   \\ \hline
        		\info{importer()}                                 &  A DETERMINER (nb pixels ?)                   \\ \hline
        		\info{exporter()}                               &  A DETERMINER (n ?)                   \\ \hline
        		\info{compressionDelta()}                                &  A DETERMINER (n ?)                   \\ \hline
        		\info{compressionPhi()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{kiemeBit()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{destructeur())}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{importer_rec()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{exporter_rec()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{compressionSansPerte_rec()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{compressionDelta_rec()}                                 &  A DETERMINER (n ?)                   \\ \hline
        		\info{compressionPhi_rec()}                                 &  A DETERMINER (n ?)                   \\ \hline
        	\end{tabular}
        	\caption{Complexités Temporelles Théoriques des opérations sur les \qt}
        \end{table}
        
        \subsubsection{Complexités temporelles expérimentales}
        
        Comme les complexités théoriques peuvent ne pas forcément parler autant que des résultats expérimentaux et afin de confirmer le bon fonctionnement des algorithmes la partie qui suit s'intéresse aux complexités temporelles obtenues lors de tests. Cette section ne s'attardera cependant mais uniquement aux résultats mais aussi à la façon de réaliser les tests ainsi que sur le contenu de ces tests et leur pertinence.
        
            \paragraph{Protocole expérimental}
            
            PLACEHOLDER
        
            \paragraph{Base de jeux de test et pertinence de ceux-ci}
            
            PLACEHOLDER
            
            \paragraph{Résultats}
            
            PLACEHOLDER

\section{Conclusion}

PLACEHOLDER

\newpage
\appendix

\section*{Annexe}

PLACEHOLDER ANNEXE

\newpage
\tableofcontents

\end{document}
